
msgid "TGZ"
msgstr "TGZ"

msgid "RPM/DEB"
msgstr "RPM/DEB"

msgid "Docker"
msgstr "Docker"

msgid "Building in Docker"
msgstr "Сборка в Docker"

msgid "Packaging the application"
msgstr "Упаковка приложения"

msgid "To package your application, use the ``pack`` command:"
msgstr "Чтобы упаковать приложение, используйте команду ``pack``:"

msgid "cartridge pack TYPE [PATH] [flags]"
msgstr "cartridge pack TYPE [PATH] [параметры]"

msgid "where:"
msgstr "Передаваемые аргументы:"

msgid "``TYPE`` (required) is the distribution type. Supported types:"
msgstr "``TYPE`` (обязательно) --- тип дистрибутива. Поддерживаемые типы:"

msgid ""
"``PATH`` (optional) is the path to the application directory. Defaults to "
"``.`` (the current directory)."
msgstr ""
"``PATH`` (необязательно) --- путь к директории приложения. Значение по "
"умолчанию: ``.`` (текущая директория)."

msgid ""
"Before packaging, ``cartridge pack`` builds the application. This process is"
" similar to what ``cartridge build`` :doc:`does <build>`. The resulting "
"artifact includes ``.rocks`` modules and executables that are specific for "
"the system where you've packaged the application. For this reason, a "
"distribution built on one OS can't be used on another---for example, an RPM "
"built on MacOS can't be installed on a CentOS machine. However, you can work"
" around this by enforcing package build in Docker via the ``--use-docker`` "
"flag."
msgstr ""
"Перед упаковкой ``cartridge pack`` собирает приложение. Это процесс схож с "
"тем, :doc:`что происходит во время <build>` ``cartridge build``. Итоговый "
"артефакт сборки включает модули ``.rocks`` и исполняемые файлы, специфичные "
"для системы, на которой вы собираете пакет приложения. Именно поэтому "
"дистрибутив, собранный на одной ОС, невозможно использовать на другой: "
"например, RPM-пакет, собранный на MacOS, не может быть установлен на машине "
"с CentOS. Обойти это ограничение можно, выбрав сборку приложения внутри "
"Docker-контейнера с помощью параметра ``--use-docker``."

msgid ""
"If you use open-source Tarantool, your artifact will have `tarantool` as a "
"dependency. Its version will be the same as in your system's ``PATH``. If "
"you use Tarantool Enterprise, your artifact will contain the ``tarantool`` "
"and ``tarantoolctl`` binaries from your current SDK."
msgstr ""
"Если вы используете версию Tarantool с открытым исходным кодом, "
"``tarantool`` будет среди зависимостей вашего артефакта. Версия Tarantool "
"при этом будет совпадать с указанной в переменной ``PATH`` в вашей системе. "
"Если же вы используете Tarantool Enterprise, ваш артефакт будет включать "
"бинарные файлы ``tarantool`` и ``tarantoolctl`` из вашего SDK."

msgid "Flags"
msgstr "Параметры"

msgid ""
"The following flags control the local packaging of any distribution type, be"
" it RPM, DEB, TGZ, or a Docker image."
msgstr ""
"Следующие параметры управляют локальной упаковкой приложения в RPM- или DEB-"
"дистрибутив, TGZ-архив или Docker-образ."

msgid "``--name``"
msgstr "``--name``"

msgid ""
"Application name. The package and the systemd service will have the same "
"name. The default name comes from the ``package`` field in the ``.rockspec``"
" file."
msgstr ""
"Имя приложения. Оно будет присвоено и пакету, и соответствующему сервису "
"systemd. По умолчанию имя берется из поля ``package`` в файле ``.rockspec``."

msgid "``--version``"
msgstr "``--version``"

msgid ""
"Application package version. Expected pattern: "
"``major.minor.patch[-count][-commit]``. Input like ``major.minor.patch`` "
"will be normalized to ``major.minor.patch-count``. By default, the version "
"string is the output of ``git describe --tags --long``. If the application "
"is not a git repository, you have to set the ``--version`` flag explicitly."
msgstr ""
"Версия пакета приложения. Ожидаемый шаблон: "
"``major.minor.patch[-count][-commit]``. Входные данные типа "
"``major.minor.patch`` будут приведены к виду ``major.minor.patch-count``. По"
" умолчанию строка версии соответствует выводу ``git describe --tags "
"--long``. Если приложение не является Git-репозиторием, необходимо явно "
"установить параметр ``--version``."

msgid "``--suffix``"
msgstr "``--suffix``"

msgid ""
"The suffix of the resulting file or image name. For example, a ``tar.gz`` "
"distribution is named according to the pattern: "
"``<name>-<version>[-<suffix>].tar.gz``."
msgstr ""
"Суффикс итогового имени файла или образа. Например, дистрибутив ``tar.gz`` "
"именуется по следующему шаблону: ``<name>-<version>[-<suffix>].tar.gz``."

msgid "``--use-docker``"
msgstr "``--use-docker``"

msgid ""
"Force Cartridge to build the application in Docker. Enforced if you're "
"building a Docker image."
msgstr ""
"Принудительная сборка приложения на Cartridge в Docker. Параметр обязателен,"
" если вы собираете Docker-образ."

msgid "``--no-cache``"
msgstr "``--no-cache``"

msgid ""
"Disable :ref:`path caching <cartridge-cli-path_caching>`. When used with "
"``cartridge pack docker``, also enforces the ``--no-cache`` ``docker`` flag."
msgstr ""
"Отключение :ref:`кэширования по путям <cartridge-cli-path_caching>`. При "
"использовании вместе с ``cartridge pack docker`` автоматически устанавливает"
" параметр ``--no-cache`` для команды ``docker``."

msgid ""
"To learn about distribution-specific flags, check the documentation for "
"creating Cartridge :doc:`RPM/DEB distributables <pack/rpm-deb>` and "
":doc:`Docker images <pack/docker>`."
msgstr ""
"Ознакомьтесь с документацией по упаковке приложений на Cartridge в "
":doc:`RPM/DEB-дистрибутивы <pack/rpm-deb>` и :doc:`Docker-образы "
"<pack/docker>`, чтобы узнать больше о параметрах, специфичных для этих "
"способов упаковки."

msgid "Details"
msgstr "Описание"

msgid "Building the package"
msgstr "Сборка пакета"

msgid ""
"By default, the package is built inside a temporary directory in "
"``~/.cartridge/tmp/``. In this way, the packaging process doesn't affect the"
" contents of your application directory."
msgstr ""
"По умолчанию пакет собирается внутри временной директории в "
"``~/.cartridge/tmp/``. Таким образом, процесс упаковки не влияет на "
"содержимое директории вашего приложения."

msgid ""
"When Cartridge copies your application files, it ignores the ``.rocks`` "
"directory."
msgstr "Копируя файлы приложения, Cartridge игнорирует директорию ``.rocks``."

msgid ""
"All file permissions are preserved in the resulting package, and the code "
"files owner is set to ``root:root``."
msgstr ""
"В итоговом пакете сохраняются все права доступа к файлам, а в качестве "
"владельца файлов кода устанавливается ``root:root``."

msgid ""
"Make sure all your application files have at least ``a+r`` permissions "
"(``a+rx`` for directories). Otherwise, ``cartridge pack`` will raise an "
"error."
msgstr ""
"Убедитесь, что для всех файлов приложения установлены права доступа не ниже "
"``a+r`` (``a+rx`` для директорий). В противном случае ``cartridge pack`` "
"выдаст ошибку."

msgid "Customizing your build directory"
msgstr "Настройка сборочной директории"

msgid ""
"You can specify a custom build directory for your application using the "
"``CARTRIDGE_TEMPDIR`` environment variable. If this directory doesn't exist,"
" it will be created, used for packaging the application, and then removed."
msgstr ""
"Указать пользовательскую директорию для сборки приложения можно с помощью "
"переменной окружения ``CARTRIDGE_TEMPDIR``. Если такой директории не "
"существует, она будет создана, использована для упаковки приложения, а затем"
" удалена."

msgid ""
"If you specify an existing directory in the ``CARTRIDGE_TEMPDIR`` "
"environment variable, the ``CARTRIDGE_TEMPDIR/cartridge.tmp`` directory will"
" be used for packaging the application and then removed. Before the "
"packaging starts, this nested directory will be cleaned up."
msgstr ""
"Если в переменной окружения ``CARTRIDGE_TEMPDIR`` указать существующую "
"директорию, то приложение будет упаковано в директории "
"``CARTRIDGE_TEMPDIR/cartridge.tmp``, которая затем будет удалена. Перед "
"началом сборки пакета эта вложенная директория будет очищена."

msgid ""
"This is especially useful if you want to use your Docker build with GitLab "
"CI. Docker volumes don't work properly with the default tmp directory in "
"this case. Use ``CARTRIDGE_TEMPDIR=. cartridge pack ...``."
msgstr ""
"Это может быть актуально при сборке Docker-образов с помощью GitLab CI, так "
"как в этом случае Docker-тома (Docker volumes) не работают должным образом с"
" директорией ``tmp`` по умолчанию. Используйте для таких случаев "
"``CARTRIDGE_TEMPDIR=. cartridge pack ...``."

msgid "How building works"
msgstr "Как работает сборка"

msgid ""
"This section concern building Cartridge applications locally. To learn about"
" building them in Docker, check the :doc:`corresponding documentation page "
"<pack/building-in-docker>`."
msgstr ""
"Этот раздел посвящен локальной сборке приложений на Cartridge. Чтобы узнать "
"о сборке в Docker, ознакомьтесь с :doc:`соответствующим разделом "
"документации <pack/building-in-docker>`."

msgid ""
"Whether you're building a TGZ archive, an RPM/DEB distributable, or a Docker"
" image, your application is built in three stages."
msgstr ""
"Независимо от того, собираете ли вы TGZ-архив, дистрибутив RPM/DEB или "
"Docker-образ, сборка включает три этапа."

msgid "Stage 1: Cleaning up the application directory"
msgstr "Этап 1. Очистка директории приложения"

msgid ""
"At this stage, some files are filtered out of the application directory."
msgstr "На этом этапе из директории приложения удаляется часть файлов."

msgid ""
"First, ``git clean -X -d -f`` removes all untracked and ignored files (it "
"works for submodules, too)."
msgstr ""
"В первую очередь с помощью ``git clean -X -d -f`` удаляются все "
"неотслеживаемые и игнорируемые файлы, в том числе относящиеся к вложенным "
"модулям."

msgid "After that, the ``.git`` directory itself is removed."
msgstr "После этого удаляется директория ``.git``."

msgid "Stage 2. Building the application"
msgstr "Этап 2. Сборка приложения"

msgid "At this stage, ``cartridge`` runs the following:"
msgstr "На этом этапе ``cartridge`` выполняет следующее:"

msgid ""
"``./cartridge.pre-build``, if it exists in the application root directory. "
"Learn more about :doc:`pre-build and post-build scripts "
"</book/cartridge/cartridge_cli/pre-post-build>`. Instead of using the pre-"
"build script, you can define the build logic by including ``cmake`` commands"
" in your ``.rockspec``, `like we do it in Cartridge "
"<https://github.com/tarantool/cartridge/blob/master/cartridge-"
"scm-1.rockspec#L26>`_."
msgstr ""
"Скрипт ``./cartridge.pre-build``, если он есть в корневой директории "
"приложения. Узнайте больше о :doc:`скриптах pre-build и post-build "
"</book/cartridge/cartridge_cli/pre-post-build>`. Вместо того, чтобы "
"использовать этот скрипт, вы можете определить правила сборки, включив в "
"файл ``.rockspec`` команды ``cmake``, `как это сделано в Cartridge "
"<https://github.com/tarantool/cartridge/blob/master/cartridge-"
"scm-1.rockspec#L26>`_."

msgid ""
"``tarantoolctl rocks make``. This requires a ``.rockspec`` file in the "
"application root directory. If you created your application from template, "
"the file is already there. ``cartridge`` installs all dependencies specified"
" in that file."
msgstr ""
"``tarantoolctl rocks make``. Чтобы выполнить эту команду, потребуется файл "
"``.rockspec`` в корневой директории приложения. Если вы создали приложение "
"по шаблону, этот файл уже находится там. ``cartridge`` установит все "
"зависимости, указанные в этом файле."

msgid ""
"As a result, the fully built application will appear in the ``.rocks`` "
"directory. You can start it locally from your application directory."
msgstr ""
"По завершении сборки приложение появится в директории ``.rocks``. Его можно "
"запустить локально из его корневой директории."

msgid "Stage 3. Cleaning up the files before packing"
msgstr "Этап 3. Удаление ненужных файлов перед сборкой пакета"

msgid ""
"At this stage, ``cartridge`` runs ``cartridge.post-build``, if it exists. "
"The post-build script removes junk files (like ``node_modules``) generated "
"during application build."
msgstr ""
"На этом этапе ``cartridge`` запускает ``cartridge.post-build``, если такой "
"скрипт существует. Скрипт post-build удаляет ненужные файлы, созданные во "
"время сборки приложения --- например, ``node_modules``."

msgid ""
"Learn more about :doc:`pre-build and post-build scripts "
"</book/cartridge/cartridge_cli/pre-post-build>`."
msgstr ""
"Подробную информацию вы найдете в :doc:`описании скриптов pre-build и post-"
"build </book/cartridge/cartridge_cli/pre-post-build>`."

msgid "Versioning"
msgstr "Версионирование"

msgid ""
"The package generates ``VERSION.lua``, a file that contains the current "
"version of the project. When you connect to an instance with :doc:`cartridge"
" connect <connect>`, you can check the project version by obtaining "
"information from this file:"
msgstr ""
"При сборке будет автоматически создан файл ``VERSION.lua``, в котором "
"хранится текущая версия приложения. При подключении к экземпляру с помощью "
":doc:`cartridge connect <connect>` вы сможете проверить версию проекта, "
"получив информацию из этого файла следующим образом:"

msgid "require('VERSION')"
msgstr "require('VERSION')"

msgid ""
"``VERSION.lua`` is also used when you call :ref:`cartridge.reload_roles() "
"<cartridge.reload_roles>`:"
msgstr ""
"``VERSION.lua`` также используется при вызове :ref:`cartridge.reload_roles()"
" <cartridge.reload_roles>`:"

msgid ""
"-- Getting the project version\n"
"require('VERSION')\n"
"-- Reloading the instances after making some changes to VERSION.lua\n"
"require('cartridge').reload_roles()\n"
"-- Getting the updated project version\n"
"require('VERSION')"
msgstr ""
"-- Получение версии проекта\n"
"require('VERSION')\n"
"-- Перезапуск экземпляров после изменения файла VERSION.lua\n"
"require('cartridge').reload_roles()\n"
"-- Получение обновленной версии проекта\n"
"require('VERSION')"

msgid ""
"If ``VERSION.lua`` is already in the application directory, it will be "
"overwritten during packaging."
msgstr ""
"Если в директории приложения уже есть файл ``VERSION.lua``, при сборке "
"пакета он будет перезаписан."

msgid "Path caching"
msgstr "Кэширование по путям"

msgid ""
"You can cache paths for packaging Cartridge applications. For example, if "
"you package an application multiple times, the same ``.rocks`` are installed"
" every time over and over. To speed up the repacking process, specify the "
"cached paths in ``pack-cache-config.yml``, a file located in the application"
" root directory."
msgstr ""
"Вы можете кэшировать директории для упаковки приложений на Cartridge. Если "
"вы собираете пакет для приложения несколько раз, одни и те же модули "
"``.rocks`` устанавливаются каждый раз заново. Чтобы ускорить процесс "
"переупаковки, укажите пути для кэширования в файле ``pack-cache-"
"config.yml``, расположенном в корневой директории приложения."

msgid ""
"By default, the ``.rocks`` directory is cached. The standard template's "
"``pack-cache-config.yml`` contains the path to that directory:"
msgstr ""
"Директория ``.rocks`` кэшируется по умолчанию. Путь к ней указан в "
"стандартной конфигурации ``pack-cache-config.yml``:"

msgid ""
"- path: '.rocks':\n"
"  key-path: 'myapp-scm-1.rockspec'\n"
"- path: 'node_modules':\n"
"  always-cache: true\n"
"- path: 'third_party/custom_module':\n"
"  key: 'simple-hash-key'"
msgstr ""
"- path: '.rocks':\n"
"  key-path: 'myapp-scm-1.rockspec'\n"
"- path: 'node_modules':\n"
"  always-cache: true\n"
"- path: 'third_party/custom_module':\n"
"  key: 'simple-hash-key'"

msgid ""
"Make sure you specify the path to ``.rocks`` from the application root "
"directory and provide a cache key. Let's look at the example above:"
msgstr ""
"Убедитесь, что вы указали путь к директории ``.rocks`` из корневой "
"директории приложения и предоставили ключ для кэширования. В примере выше:"

msgid ""
"``<path-to-myapp>/.rocks`` will be cached depending on the content of "
"``myapp-scm-1.rockspec``."
msgstr ""
"директория ``<путь_к_myapp>/.rocks`` будет кэширована в зависимости от "
"содержания ``myapp-scm-1.rockspec``;"

msgid "``<path-to-myapp>/node_modules`` will always be cached."
msgstr ""
"директория ``<path-to-myapp>/node_modules`` всегда будет добавляться в кэш."

msgid ""
"``<path-to-myapp>/third_party/custom_module`` will be cached depending on "
"``simple-hash-key``."
msgstr ""
"директория ``<путь_к_myapp>/third_party/custom_module`` будет кэширована в "
"зависимости от значения ``simple-hash-key``;"

msgid ""
"You can't combine these options. For example, you can't specify ``always-"
"cache`` and ``key-path`` at the same time."
msgstr ""
"Эти параметры нельзя комбинировать: вы не можете одновременно указать и "
"``always-cache``, и ``key-path``."

msgid ""
"One project path can only have one caching key. Suppose you cached "
"``.rocks`` with a ``.rockspec`` file as ``key-path``. Then you changed the "
"contents of ``.rockspec`` and ran ``cartridge pack``. In this case, the old "
"cache (associated with the old key) for the project's ``.rocks`` directory "
"path will be deleted. After packing, the new ``.rocks`` cache path will be "
"saved with the new key."
msgstr ""
"У каждого пути в проекте может быть только один ключ кэширования. "
"Предположим, вы кэшировали ``.rocks``, указав файл ``.rockspec`` в качестве "
"``key-path``. Затем вы изменили содержимое файла ``.rockspec`` и запустили "
"``cartridge pack``. В этом случае старый кэш директории ``.rocks``, "
"связанный со старым ключом, будет удален. Новый кэш для ``.rocks`` будет "
"сохранен с новым ключом после упаковки."

msgid ""
"There can be no more than **5** projects in the cache that have cached "
"paths. If the 6th project appears, the oldest existing project is removed "
"from the cache directory. However, this is not the case for cached paths "
"within a single project. You can cache as many paths as you like as long as "
"they are in one project."
msgstr ""
"В кэше можно хранить не более **5** проектов с путями для кэширования. При "
"добавлении шестого самый старый проект будет удален из директории кэша. Для "
"каждого проекта при этом можно добавлять сколько угодно путей для "
"кэширования."

msgid ""
"To disable caching, use the ``--no-cache`` flag or remove paths from ``pack-"
"cache-config.yml``. To completely reset the cache, delete the "
"``~/.cartridge/tmp/cache`` directory."
msgstr ""
"Чтобы отключить кэширование, используйте параметр ``--no-cache`` или удалите"
" пути из ``pack-cache-config.yml``. Полностью сбросить кэш можно, удалив "
"директорию ``~/.cartridge/tmp/cache``."
